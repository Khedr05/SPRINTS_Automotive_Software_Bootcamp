
led_sequance_v1.0.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000530  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000020  00800060  00000530  000005a4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000030  00000000  00000000  000005c4  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000005f4  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000110  00000000  00000000  00000630  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000196f  00000000  00000000  00000740  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000a32  00000000  00000000  000020af  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000b50  00000000  00000000  00002ae1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000214  00000000  00000000  00003634  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000008ad  00000000  00000000  00003848  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000c62  00000000  00000000  000040f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000c0  00000000  00000000  00004d57  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
   8:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
   c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  10:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  14:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  18:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  1c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  20:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  24:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  28:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  2c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  30:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  34:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  38:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  3c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  40:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  44:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  48:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  4c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  50:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e0 e3       	ldi	r30, 0x30	; 48
  68:	f5 e0       	ldi	r31, 0x05	; 5
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a0 38       	cpi	r26, 0x80	; 128
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>
  76:	0e 94 da 01 	call	0x3b4	; 0x3b4 <main>
  7a:	0c 94 96 02 	jmp	0x52c	; 0x52c <_exit>

0000007e <__bad_interrupt>:
  7e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000082 <appmain>:




void appmain(void)
{
  82:	cf 93       	push	r28
  84:	df 93       	push	r29
  86:	1f 92       	push	r1
  88:	cd b7       	in	r28, 0x3d	; 61
  8a:	de b7       	in	r29, 0x3e	; 62
	Uint8_t pressCounterFlag = ZERO_PRESS;
	EN_PUSH_BTN_state_t btnState = PUSH_BTN_STATE_RELEASED;
  8c:	81 e0       	ldi	r24, 0x01	; 1
  8e:	89 83       	std	Y+1, r24	; 0x01

	LED_initialize(&led0);
  90:	86 e6       	ldi	r24, 0x66	; 102
  92:	90 e0       	ldi	r25, 0x00	; 0
  94:	0e 94 1b 01 	call	0x236	; 0x236 <LED_initialize>
	LED_initialize(&led1);
  98:	85 e6       	ldi	r24, 0x65	; 101
  9a:	90 e0       	ldi	r25, 0x00	; 0
  9c:	0e 94 1b 01 	call	0x236	; 0x236 <LED_initialize>
	LED_initialize(&led2);
  a0:	84 e6       	ldi	r24, 0x64	; 100
  a2:	90 e0       	ldi	r25, 0x00	; 0
  a4:	0e 94 1b 01 	call	0x236	; 0x236 <LED_initialize>
	LED_initialize(&led3);
  a8:	83 e6       	ldi	r24, 0x63	; 99
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	0e 94 1b 01 	call	0x236	; 0x236 <LED_initialize>

	PUSH_BTN_intialize(&btn0);
  b0:	80 e6       	ldi	r24, 0x60	; 96
  b2:	90 e0       	ldi	r25, 0x00	; 0
  b4:	0e 94 98 01 	call	0x330	; 0x330 <PUSH_BTN_intialize>



void appmain(void)
{
	Uint8_t pressCounterFlag = ZERO_PRESS;
  b8:	10 e0       	ldi	r17, 0x00	; 0

	PUSH_BTN_intialize(&btn0);

	while(1)
	{
		PUSH_BTN_read_state(&btn0,&btnState);
  ba:	be 01       	movw	r22, r28
  bc:	6f 5f       	subi	r22, 0xFF	; 255
  be:	7f 4f       	sbci	r23, 0xFF	; 255
  c0:	80 e6       	ldi	r24, 0x60	; 96
  c2:	90 e0       	ldi	r25, 0x00	; 0
  c4:	0e 94 9f 01 	call	0x33e	; 0x33e <PUSH_BTN_read_state>

		if(btnState == PUSH_BTN_STATE_PRESSED)
  c8:	89 81       	ldd	r24, Y+1	; 0x01
  ca:	81 11       	cpse	r24, r1
  cc:	0a c0       	rjmp	.+20     	; 0xe2 <appmain+0x60>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  ce:	2f e7       	ldi	r18, 0x7F	; 127
  d0:	88 e3       	ldi	r24, 0x38	; 56
  d2:	91 e0       	ldi	r25, 0x01	; 1
  d4:	21 50       	subi	r18, 0x01	; 1
  d6:	80 40       	sbci	r24, 0x00	; 0
  d8:	90 40       	sbci	r25, 0x00	; 0
  da:	e1 f7       	brne	.-8      	; 0xd4 <appmain+0x52>
  dc:	00 c0       	rjmp	.+0      	; 0xde <appmain+0x5c>
  de:	00 00       	nop
		{
			_delay_ms(50);
			pressCounterFlag++;
  e0:	1f 5f       	subi	r17, 0xFF	; 255
		}

		if(pressCounterFlag == ONE_PRESS)
  e2:	11 30       	cpi	r17, 0x01	; 1
  e4:	89 f4       	brne	.+34     	; 0x108 <appmain+0x86>
		{
			LED_turn_on(&led0);
  e6:	86 e6       	ldi	r24, 0x66	; 102
  e8:	90 e0       	ldi	r25, 0x00	; 0
  ea:	0e 94 44 01 	call	0x288	; 0x288 <LED_turn_on>
			LED_turn_off(&led1);
  ee:	85 e6       	ldi	r24, 0x65	; 101
  f0:	90 e0       	ldi	r25, 0x00	; 0
  f2:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
			LED_turn_off(&led2);
  f6:	84 e6       	ldi	r24, 0x64	; 100
  f8:	90 e0       	ldi	r25, 0x00	; 0
  fa:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
			LED_turn_off(&led3);
  fe:	83 e6       	ldi	r24, 0x63	; 99
 100:	90 e0       	ldi	r25, 0x00	; 0
 102:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
 106:	d9 cf       	rjmp	.-78     	; 0xba <appmain+0x38>
		}
		else if(pressCounterFlag == TWO_PRESS)
 108:	12 30       	cpi	r17, 0x02	; 2
 10a:	89 f4       	brne	.+34     	; 0x12e <appmain+0xac>
		{
			LED_turn_on(&led0);
 10c:	86 e6       	ldi	r24, 0x66	; 102
 10e:	90 e0       	ldi	r25, 0x00	; 0
 110:	0e 94 44 01 	call	0x288	; 0x288 <LED_turn_on>
			LED_turn_on(&led1);
 114:	85 e6       	ldi	r24, 0x65	; 101
 116:	90 e0       	ldi	r25, 0x00	; 0
 118:	0e 94 44 01 	call	0x288	; 0x288 <LED_turn_on>
			LED_turn_off(&led2);
 11c:	84 e6       	ldi	r24, 0x64	; 100
 11e:	90 e0       	ldi	r25, 0x00	; 0
 120:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
			LED_turn_off(&led3);
 124:	83 e6       	ldi	r24, 0x63	; 99
 126:	90 e0       	ldi	r25, 0x00	; 0
 128:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
 12c:	c6 cf       	rjmp	.-116    	; 0xba <appmain+0x38>
		}
		else if(pressCounterFlag == THREE_PRESS)
 12e:	13 30       	cpi	r17, 0x03	; 3
 130:	89 f4       	brne	.+34     	; 0x154 <appmain+0xd2>
		{
			LED_turn_on(&led0);
 132:	86 e6       	ldi	r24, 0x66	; 102
 134:	90 e0       	ldi	r25, 0x00	; 0
 136:	0e 94 44 01 	call	0x288	; 0x288 <LED_turn_on>
			LED_turn_on(&led1);
 13a:	85 e6       	ldi	r24, 0x65	; 101
 13c:	90 e0       	ldi	r25, 0x00	; 0
 13e:	0e 94 44 01 	call	0x288	; 0x288 <LED_turn_on>
			LED_turn_on(&led2);
 142:	84 e6       	ldi	r24, 0x64	; 100
 144:	90 e0       	ldi	r25, 0x00	; 0
 146:	0e 94 44 01 	call	0x288	; 0x288 <LED_turn_on>
			LED_turn_off(&led3);
 14a:	83 e6       	ldi	r24, 0x63	; 99
 14c:	90 e0       	ldi	r25, 0x00	; 0
 14e:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
 152:	b3 cf       	rjmp	.-154    	; 0xba <appmain+0x38>
		}
		else if(pressCounterFlag == FOUR_PRESS)
 154:	14 30       	cpi	r17, 0x04	; 4
 156:	89 f4       	brne	.+34     	; 0x17a <appmain+0xf8>
		{

			LED_turn_on(&led0);
 158:	86 e6       	ldi	r24, 0x66	; 102
 15a:	90 e0       	ldi	r25, 0x00	; 0
 15c:	0e 94 44 01 	call	0x288	; 0x288 <LED_turn_on>
			LED_turn_on(&led1);
 160:	85 e6       	ldi	r24, 0x65	; 101
 162:	90 e0       	ldi	r25, 0x00	; 0
 164:	0e 94 44 01 	call	0x288	; 0x288 <LED_turn_on>
			LED_turn_on(&led2);
 168:	84 e6       	ldi	r24, 0x64	; 100
 16a:	90 e0       	ldi	r25, 0x00	; 0
 16c:	0e 94 44 01 	call	0x288	; 0x288 <LED_turn_on>
			LED_turn_on(&led3);
 170:	83 e6       	ldi	r24, 0x63	; 99
 172:	90 e0       	ldi	r25, 0x00	; 0
 174:	0e 94 44 01 	call	0x288	; 0x288 <LED_turn_on>
 178:	a0 cf       	rjmp	.-192    	; 0xba <appmain+0x38>
		}
		else if(pressCounterFlag == FIVE_PRESS)
 17a:	15 30       	cpi	r17, 0x05	; 5
 17c:	89 f4       	brne	.+34     	; 0x1a0 <appmain+0x11e>
		{

			LED_turn_off(&led0);
 17e:	86 e6       	ldi	r24, 0x66	; 102
 180:	90 e0       	ldi	r25, 0x00	; 0
 182:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
			LED_turn_on(&led1);
 186:	85 e6       	ldi	r24, 0x65	; 101
 188:	90 e0       	ldi	r25, 0x00	; 0
 18a:	0e 94 44 01 	call	0x288	; 0x288 <LED_turn_on>
			LED_turn_on(&led2);
 18e:	84 e6       	ldi	r24, 0x64	; 100
 190:	90 e0       	ldi	r25, 0x00	; 0
 192:	0e 94 44 01 	call	0x288	; 0x288 <LED_turn_on>
			LED_turn_on(&led3);
 196:	83 e6       	ldi	r24, 0x63	; 99
 198:	90 e0       	ldi	r25, 0x00	; 0
 19a:	0e 94 44 01 	call	0x288	; 0x288 <LED_turn_on>
 19e:	8d cf       	rjmp	.-230    	; 0xba <appmain+0x38>
		}
		else if(pressCounterFlag == SIX_PRESS)
 1a0:	16 30       	cpi	r17, 0x06	; 6
 1a2:	89 f4       	brne	.+34     	; 0x1c6 <appmain+0x144>
		{
			LED_turn_off(&led0);
 1a4:	86 e6       	ldi	r24, 0x66	; 102
 1a6:	90 e0       	ldi	r25, 0x00	; 0
 1a8:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
			LED_turn_off(&led1);
 1ac:	85 e6       	ldi	r24, 0x65	; 101
 1ae:	90 e0       	ldi	r25, 0x00	; 0
 1b0:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
			LED_turn_on(&led2);
 1b4:	84 e6       	ldi	r24, 0x64	; 100
 1b6:	90 e0       	ldi	r25, 0x00	; 0
 1b8:	0e 94 44 01 	call	0x288	; 0x288 <LED_turn_on>
			LED_turn_on(&led3);
 1bc:	83 e6       	ldi	r24, 0x63	; 99
 1be:	90 e0       	ldi	r25, 0x00	; 0
 1c0:	0e 94 44 01 	call	0x288	; 0x288 <LED_turn_on>
 1c4:	7a cf       	rjmp	.-268    	; 0xba <appmain+0x38>
		}
		else if(pressCounterFlag == SEVEN_PRESS)
 1c6:	17 30       	cpi	r17, 0x07	; 7
 1c8:	89 f4       	brne	.+34     	; 0x1ec <appmain+0x16a>
		{
			LED_turn_off(&led0);
 1ca:	86 e6       	ldi	r24, 0x66	; 102
 1cc:	90 e0       	ldi	r25, 0x00	; 0
 1ce:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
			LED_turn_off(&led1);
 1d2:	85 e6       	ldi	r24, 0x65	; 101
 1d4:	90 e0       	ldi	r25, 0x00	; 0
 1d6:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
			LED_turn_off(&led2);
 1da:	84 e6       	ldi	r24, 0x64	; 100
 1dc:	90 e0       	ldi	r25, 0x00	; 0
 1de:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
			LED_turn_on(&led3);
 1e2:	83 e6       	ldi	r24, 0x63	; 99
 1e4:	90 e0       	ldi	r25, 0x00	; 0
 1e6:	0e 94 44 01 	call	0x288	; 0x288 <LED_turn_on>
 1ea:	67 cf       	rjmp	.-306    	; 0xba <appmain+0x38>
		}
		else if(pressCounterFlag == EIGHT_PRESS)
 1ec:	18 30       	cpi	r17, 0x08	; 8
 1ee:	91 f4       	brne	.+36     	; 0x214 <appmain+0x192>
		{
			LED_turn_off(&led0);
 1f0:	86 e6       	ldi	r24, 0x66	; 102
 1f2:	90 e0       	ldi	r25, 0x00	; 0
 1f4:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
			LED_turn_off(&led1);
 1f8:	85 e6       	ldi	r24, 0x65	; 101
 1fa:	90 e0       	ldi	r25, 0x00	; 0
 1fc:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
			LED_turn_off(&led2);
 200:	84 e6       	ldi	r24, 0x64	; 100
 202:	90 e0       	ldi	r25, 0x00	; 0
 204:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
			LED_turn_off(&led3);
 208:	83 e6       	ldi	r24, 0x63	; 99
 20a:	90 e0       	ldi	r25, 0x00	; 0
 20c:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
			pressCounterFlag = ZERO_PRESS;
 210:	10 e0       	ldi	r17, 0x00	; 0
 212:	53 cf       	rjmp	.-346    	; 0xba <appmain+0x38>
		}
		else
		{
			LED_turn_off(&led0);
 214:	86 e6       	ldi	r24, 0x66	; 102
 216:	90 e0       	ldi	r25, 0x00	; 0
 218:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
			LED_turn_off(&led1);
 21c:	85 e6       	ldi	r24, 0x65	; 101
 21e:	90 e0       	ldi	r25, 0x00	; 0
 220:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
			LED_turn_off(&led2);
 224:	84 e6       	ldi	r24, 0x64	; 100
 226:	90 e0       	ldi	r25, 0x00	; 0
 228:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
			LED_turn_off(&led3);
 22c:	83 e6       	ldi	r24, 0x63	; 99
 22e:	90 e0       	ldi	r25, 0x00	; 0
 230:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LED_turn_off>
 234:	42 cf       	rjmp	.-380    	; 0xba <appmain+0x38>

00000236 <LED_initialize>:
 */

#include"LED_interface.h"

Std_ReturnType LED_initialize(const ST_led_t *led)
{
 236:	cf 93       	push	r28
 238:	df 93       	push	r29
 23a:	1f 92       	push	r1
 23c:	cd b7       	in	r28, 0x3d	; 61
 23e:	de b7       	in	r29, 0x3e	; 62
	Std_ReturnType ret = E_NOT_OK;
	if(PTR_NULL == led)
 240:	00 97       	sbiw	r24, 0x00	; 0
 242:	e9 f0       	breq	.+58     	; 0x27e <LED_initialize+0x48>
 244:	fc 01       	movw	r30, r24
	}
	else
	{
		ST_pin_config_t LED_pin_obj =
		{
			.port = led->port_name,
 246:	20 81       	ld	r18, Z
 248:	92 2f       	mov	r25, r18
 24a:	97 70       	andi	r25, 0x07	; 7
	{
		ret = E_NOT_OK;
	}
	else
	{
		ST_pin_config_t LED_pin_obj =
 24c:	89 81       	ldd	r24, Y+1	; 0x01
 24e:	88 7f       	andi	r24, 0xF8	; 248
 250:	89 2b       	or	r24, r25
		{
			.port = led->port_name,
			.pin = led->pin,
 252:	92 2f       	mov	r25, r18
 254:	96 95       	lsr	r25
 256:	96 95       	lsr	r25
 258:	96 95       	lsr	r25
	{
		ret = E_NOT_OK;
	}
	else
	{
		ST_pin_config_t LED_pin_obj =
 25a:	97 70       	andi	r25, 0x07	; 7
 25c:	99 0f       	add	r25, r25
 25e:	99 0f       	add	r25, r25
 260:	99 0f       	add	r25, r25
 262:	87 7c       	andi	r24, 0xC7	; 199
 264:	89 2b       	or	r24, r25
		{
			.port = led->port_name,
			.pin = led->pin,
			.direction = GPIO_DIRECTION_OUTPUT,
			.logic = led->led_status
 266:	26 fb       	bst	r18, 6
 268:	22 27       	eor	r18, r18
 26a:	20 f9       	bld	r18, 0
	{
		ret = E_NOT_OK;
	}
	else
	{
		ST_pin_config_t LED_pin_obj =
 26c:	80 64       	ori	r24, 0x40	; 64
 26e:	20 fb       	bst	r18, 0
 270:	87 f9       	bld	r24, 7
 272:	89 83       	std	Y+1, r24	; 0x01
			.port = led->port_name,
			.pin = led->pin,
			.direction = GPIO_DIRECTION_OUTPUT,
			.logic = led->led_status
		};
		ret = GPIO_pin_intialize(&LED_pin_obj);
 274:	ce 01       	movw	r24, r28
 276:	01 96       	adiw	r24, 0x01	; 1
 278:	0e 94 83 02 	call	0x506	; 0x506 <GPIO_pin_intialize>
 27c:	01 c0       	rjmp	.+2      	; 0x280 <LED_initialize+0x4a>
Std_ReturnType LED_initialize(const ST_led_t *led)
{
	Std_ReturnType ret = E_NOT_OK;
	if(PTR_NULL == led)
	{
		ret = E_NOT_OK;
 27e:	80 e0       	ldi	r24, 0x00	; 0
			.logic = led->led_status
		};
		ret = GPIO_pin_intialize(&LED_pin_obj);
	}
	return ret;
}
 280:	0f 90       	pop	r0
 282:	df 91       	pop	r29
 284:	cf 91       	pop	r28
 286:	08 95       	ret

00000288 <LED_turn_on>:
Std_ReturnType LED_turn_on(const ST_led_t *led)
{
 288:	cf 93       	push	r28
 28a:	df 93       	push	r29
 28c:	1f 92       	push	r1
 28e:	cd b7       	in	r28, 0x3d	; 61
 290:	de b7       	in	r29, 0x3e	; 62
	Std_ReturnType ret = E_NOT_OK;
	if(PTR_NULL == led)
 292:	00 97       	sbiw	r24, 0x00	; 0
 294:	f1 f0       	breq	.+60     	; 0x2d2 <LED_turn_on+0x4a>
 296:	fc 01       	movw	r30, r24
	}
	else
	{
		ST_pin_config_t LED_pin_obj =
		{
				.port = led->port_name,
 298:	20 81       	ld	r18, Z
 29a:	92 2f       	mov	r25, r18
 29c:	97 70       	andi	r25, 0x07	; 7
	{
		ret = E_NOT_OK;
	}
	else
	{
		ST_pin_config_t LED_pin_obj =
 29e:	89 81       	ldd	r24, Y+1	; 0x01
 2a0:	88 7f       	andi	r24, 0xF8	; 248
 2a2:	89 2b       	or	r24, r25
		{
				.port = led->port_name,
				.pin = led->pin,
 2a4:	92 2f       	mov	r25, r18
 2a6:	96 95       	lsr	r25
 2a8:	96 95       	lsr	r25
 2aa:	96 95       	lsr	r25
	{
		ret = E_NOT_OK;
	}
	else
	{
		ST_pin_config_t LED_pin_obj =
 2ac:	97 70       	andi	r25, 0x07	; 7
 2ae:	99 0f       	add	r25, r25
 2b0:	99 0f       	add	r25, r25
 2b2:	99 0f       	add	r25, r25
 2b4:	87 7c       	andi	r24, 0xC7	; 199
 2b6:	89 2b       	or	r24, r25
		{
				.port = led->port_name,
				.pin = led->pin,
				.direction = GPIO_DIRECTION_OUTPUT,
				.logic = led->led_status
 2b8:	26 fb       	bst	r18, 6
 2ba:	22 27       	eor	r18, r18
 2bc:	20 f9       	bld	r18, 0
	{
		ret = E_NOT_OK;
	}
	else
	{
		ST_pin_config_t LED_pin_obj =
 2be:	80 64       	ori	r24, 0x40	; 64
 2c0:	20 fb       	bst	r18, 0
 2c2:	87 f9       	bld	r24, 7
 2c4:	89 83       	std	Y+1, r24	; 0x01
				.port = led->port_name,
				.pin = led->pin,
				.direction = GPIO_DIRECTION_OUTPUT,
				.logic = led->led_status
		};
		ret = GPIO_pin_write_logic(&LED_pin_obj , GPIO_LOGIC_HIGH);
 2c6:	61 e0       	ldi	r22, 0x01	; 1
 2c8:	ce 01       	movw	r24, r28
 2ca:	01 96       	adiw	r24, 0x01	; 1
 2cc:	0e 94 1e 02 	call	0x43c	; 0x43c <GPIO_pin_write_logic>
 2d0:	01 c0       	rjmp	.+2      	; 0x2d4 <LED_turn_on+0x4c>
Std_ReturnType LED_turn_on(const ST_led_t *led)
{
	Std_ReturnType ret = E_NOT_OK;
	if(PTR_NULL == led)
	{
		ret = E_NOT_OK;
 2d2:	80 e0       	ldi	r24, 0x00	; 0
				.logic = led->led_status
		};
		ret = GPIO_pin_write_logic(&LED_pin_obj , GPIO_LOGIC_HIGH);
	}
	return ret;
}
 2d4:	0f 90       	pop	r0
 2d6:	df 91       	pop	r29
 2d8:	cf 91       	pop	r28
 2da:	08 95       	ret

000002dc <LED_turn_off>:
Std_ReturnType LED_turn_off(const ST_led_t *led)
{
 2dc:	cf 93       	push	r28
 2de:	df 93       	push	r29
 2e0:	1f 92       	push	r1
 2e2:	cd b7       	in	r28, 0x3d	; 61
 2e4:	de b7       	in	r29, 0x3e	; 62
	Std_ReturnType ret = E_NOT_OK;
	if(PTR_NULL == led)
 2e6:	00 97       	sbiw	r24, 0x00	; 0
 2e8:	f1 f0       	breq	.+60     	; 0x326 <LED_turn_off+0x4a>
 2ea:	fc 01       	movw	r30, r24
	}
	else
	{
		ST_pin_config_t LED_pin_obj =
		{
				.port = led->port_name,
 2ec:	20 81       	ld	r18, Z
 2ee:	92 2f       	mov	r25, r18
 2f0:	97 70       	andi	r25, 0x07	; 7
	{
		ret = E_NOT_OK;
	}
	else
	{
		ST_pin_config_t LED_pin_obj =
 2f2:	89 81       	ldd	r24, Y+1	; 0x01
 2f4:	88 7f       	andi	r24, 0xF8	; 248
 2f6:	89 2b       	or	r24, r25
		{
				.port = led->port_name,
				.pin = led->pin,
 2f8:	92 2f       	mov	r25, r18
 2fa:	96 95       	lsr	r25
 2fc:	96 95       	lsr	r25
 2fe:	96 95       	lsr	r25
	{
		ret = E_NOT_OK;
	}
	else
	{
		ST_pin_config_t LED_pin_obj =
 300:	97 70       	andi	r25, 0x07	; 7
 302:	99 0f       	add	r25, r25
 304:	99 0f       	add	r25, r25
 306:	99 0f       	add	r25, r25
 308:	87 7c       	andi	r24, 0xC7	; 199
 30a:	89 2b       	or	r24, r25
		{
				.port = led->port_name,
				.pin = led->pin,
				.direction = GPIO_DIRECTION_OUTPUT,
				.logic = led->led_status
 30c:	26 fb       	bst	r18, 6
 30e:	22 27       	eor	r18, r18
 310:	20 f9       	bld	r18, 0
	{
		ret = E_NOT_OK;
	}
	else
	{
		ST_pin_config_t LED_pin_obj =
 312:	80 64       	ori	r24, 0x40	; 64
 314:	20 fb       	bst	r18, 0
 316:	87 f9       	bld	r24, 7
 318:	89 83       	std	Y+1, r24	; 0x01
				.port = led->port_name,
				.pin = led->pin,
				.direction = GPIO_DIRECTION_OUTPUT,
				.logic = led->led_status
		};
		ret = GPIO_pin_write_logic(&LED_pin_obj , GPIO_LOGIC_LOW);
 31a:	60 e0       	ldi	r22, 0x00	; 0
 31c:	ce 01       	movw	r24, r28
 31e:	01 96       	adiw	r24, 0x01	; 1
 320:	0e 94 1e 02 	call	0x43c	; 0x43c <GPIO_pin_write_logic>
 324:	01 c0       	rjmp	.+2      	; 0x328 <LED_turn_off+0x4c>
Std_ReturnType LED_turn_off(const ST_led_t *led)
{
	Std_ReturnType ret = E_NOT_OK;
	if(PTR_NULL == led)
	{
		ret = E_NOT_OK;
 326:	80 e0       	ldi	r24, 0x00	; 0
				.logic = led->led_status
		};
		ret = GPIO_pin_write_logic(&LED_pin_obj , GPIO_LOGIC_LOW);
	}
	return ret;
}
 328:	0f 90       	pop	r0
 32a:	df 91       	pop	r29
 32c:	cf 91       	pop	r28
 32e:	08 95       	ret

00000330 <PUSH_BTN_intialize>:
#include"PB_interface.h"

Std_ReturnType PUSH_BTN_intialize(const ST_PUSH_BTN_t *btn)
{
	Std_ReturnType ret = E_NOT_OK;
	if(PTR_NULL == btn)
 330:	00 97       	sbiw	r24, 0x00	; 0
 332:	19 f0       	breq	.+6      	; 0x33a <PUSH_BTN_intialize+0xa>
	{
		ret = E_NOT_OK;
	}
	else
	{
		ret = GPIO_pin_direction_intialize(&(btn->PUSH_BTN_pin));
 334:	0e 94 dd 01 	call	0x3ba	; 0x3ba <GPIO_pin_direction_intialize>
 338:	08 95       	ret
Std_ReturnType PUSH_BTN_intialize(const ST_PUSH_BTN_t *btn)
{
	Std_ReturnType ret = E_NOT_OK;
	if(PTR_NULL == btn)
	{
		ret = E_NOT_OK;
 33a:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		ret = GPIO_pin_direction_intialize(&(btn->PUSH_BTN_pin));
	}
	return ret;
}
 33c:	08 95       	ret

0000033e <PUSH_BTN_read_state>:

Std_ReturnType PUSH_BTN_read_state(const ST_PUSH_BTN_t *btn , EN_PUSH_BTN_state_t *btn_state)
{
 33e:	ef 92       	push	r14
 340:	ff 92       	push	r15
 342:	0f 93       	push	r16
 344:	1f 93       	push	r17
 346:	cf 93       	push	r28
 348:	df 93       	push	r29
 34a:	1f 92       	push	r1
 34c:	cd b7       	in	r28, 0x3d	; 61
 34e:	de b7       	in	r29, 0x3e	; 62
	Std_ReturnType ret = E_NOT_OK;
	if(PTR_NULL == btn || PTR_NULL == btn_state )
 350:	00 97       	sbiw	r24, 0x00	; 0
 352:	29 f1       	breq	.+74     	; 0x39e <PUSH_BTN_read_state+0x60>
 354:	61 15       	cp	r22, r1
 356:	71 05       	cpc	r23, r1
 358:	21 f1       	breq	.+72     	; 0x3a2 <PUSH_BTN_read_state+0x64>
 35a:	7b 01       	movw	r14, r22
 35c:	8c 01       	movw	r16, r24
	{
		ret = E_NOT_OK;
	}
	else
	{
		EN_logic_t pin_logic_status = GPIO_LOGIC_LOW;
 35e:	19 82       	std	Y+1, r1	; 0x01
		ret = GPIO_pin_read_logic(&(btn->PUSH_BTN_pin) , &pin_logic_status);
 360:	be 01       	movw	r22, r28
 362:	6f 5f       	subi	r22, 0xFF	; 255
 364:	7f 4f       	sbci	r23, 0xFF	; 255
 366:	0e 94 5e 02 	call	0x4bc	; 0x4bc <GPIO_pin_read_logic>
		if(PUSH_BTN_PULL_UP == btn->PUSH_BTN_connection)
 36a:	f8 01       	movw	r30, r16
 36c:	82 81       	ldd	r24, Z+2	; 0x02
 36e:	81 11       	cpse	r24, r1
 370:	09 c0       	rjmp	.+18     	; 0x384 <PUSH_BTN_read_state+0x46>
		{
			if(GPIO_LOGIC_HIGH == pin_logic_status)
 372:	89 81       	ldd	r24, Y+1	; 0x01
 374:	81 30       	cpi	r24, 0x01	; 1
 376:	19 f4       	brne	.+6      	; 0x37e <PUSH_BTN_read_state+0x40>
			{
				*btn_state = PUSH_BTN_STATE_RELEASED;
 378:	f7 01       	movw	r30, r14
 37a:	80 83       	st	Z, r24
 37c:	0e c0       	rjmp	.+28     	; 0x39a <PUSH_BTN_read_state+0x5c>
			}
			else
			{
				*btn_state = PUSH_BTN_STATE_PRESSED;
 37e:	f7 01       	movw	r30, r14
 380:	10 82       	st	Z, r1
 382:	0b c0       	rjmp	.+22     	; 0x39a <PUSH_BTN_read_state+0x5c>
			}
		}
		else if(PUSH_BTN_PULL_DOWN == btn->PUSH_BTN_connection)
 384:	81 30       	cpi	r24, 0x01	; 1
 386:	49 f4       	brne	.+18     	; 0x39a <PUSH_BTN_read_state+0x5c>
		{
			if(GPIO_LOGIC_HIGH == pin_logic_status)
 388:	89 81       	ldd	r24, Y+1	; 0x01
 38a:	81 30       	cpi	r24, 0x01	; 1
 38c:	19 f4       	brne	.+6      	; 0x394 <PUSH_BTN_read_state+0x56>
			{
				*btn_state = PUSH_BTN_STATE_PRESSED;
 38e:	f7 01       	movw	r30, r14
 390:	10 82       	st	Z, r1
 392:	03 c0       	rjmp	.+6      	; 0x39a <PUSH_BTN_read_state+0x5c>
			}
			else
			{
				*btn_state = PUSH_BTN_STATE_RELEASED;
 394:	81 e0       	ldi	r24, 0x01	; 1
 396:	f7 01       	movw	r30, r14
 398:	80 83       	st	Z, r24
			}
		}
		else{/* nothing */}
		ret = E_OK;
 39a:	81 e0       	ldi	r24, 0x01	; 1
 39c:	03 c0       	rjmp	.+6      	; 0x3a4 <PUSH_BTN_read_state+0x66>
Std_ReturnType PUSH_BTN_read_state(const ST_PUSH_BTN_t *btn , EN_PUSH_BTN_state_t *btn_state)
{
	Std_ReturnType ret = E_NOT_OK;
	if(PTR_NULL == btn || PTR_NULL == btn_state )
	{
		ret = E_NOT_OK;
 39e:	80 e0       	ldi	r24, 0x00	; 0
 3a0:	01 c0       	rjmp	.+2      	; 0x3a4 <PUSH_BTN_read_state+0x66>
 3a2:	80 e0       	ldi	r24, 0x00	; 0
		else{/* nothing */}
		ret = E_OK;
	}

	return ret;
}
 3a4:	0f 90       	pop	r0
 3a6:	df 91       	pop	r29
 3a8:	cf 91       	pop	r28
 3aa:	1f 91       	pop	r17
 3ac:	0f 91       	pop	r16
 3ae:	ff 90       	pop	r15
 3b0:	ef 90       	pop	r14
 3b2:	08 95       	ret

000003b4 <main>:
#include "APPLICATION/app.h"


void main(void)
{
	appmain();
 3b4:	0e 94 41 00 	call	0x82	; 0x82 <appmain>
 3b8:	08 95       	ret

000003ba <GPIO_pin_direction_intialize>:
       TOGGLE_BIT(*port_registers[_pin_config->port],_pin_config->pin);
       ret = E_OK;
    }

    return ret;
}
 3ba:	fc 01       	movw	r30, r24
 3bc:	89 2b       	or	r24, r25
 3be:	d1 f1       	breq	.+116    	; 0x434 <__EEPROM_REGION_LENGTH__+0x34>
 3c0:	20 81       	ld	r18, Z
 3c2:	26 95       	lsr	r18
 3c4:	26 95       	lsr	r18
 3c6:	26 95       	lsr	r18
 3c8:	27 70       	andi	r18, 0x07	; 7
 3ca:	80 81       	ld	r24, Z
 3cc:	86 fb       	bst	r24, 6
 3ce:	99 27       	eor	r25, r25
 3d0:	90 f9       	bld	r25, 0
 3d2:	86 ff       	sbrs	r24, 6
 3d4:	18 c0       	rjmp	.+48     	; 0x406 <__EEPROM_REGION_LENGTH__+0x6>
 3d6:	91 30       	cpi	r25, 0x01	; 1
 3d8:	79 f5       	brne	.+94     	; 0x438 <__EEPROM_REGION_LENGTH__+0x38>
 3da:	e8 2f       	mov	r30, r24
 3dc:	e7 70       	andi	r30, 0x07	; 7
 3de:	f0 e0       	ldi	r31, 0x00	; 0
 3e0:	ee 0f       	add	r30, r30
 3e2:	ff 1f       	adc	r31, r31
 3e4:	e9 58       	subi	r30, 0x89	; 137
 3e6:	ff 4f       	sbci	r31, 0xFF	; 255
 3e8:	01 90       	ld	r0, Z+
 3ea:	f0 81       	ld	r31, Z
 3ec:	e0 2d       	mov	r30, r0
 3ee:	30 81       	ld	r19, Z
 3f0:	81 e0       	ldi	r24, 0x01	; 1
 3f2:	90 e0       	ldi	r25, 0x00	; 0
 3f4:	02 c0       	rjmp	.+4      	; 0x3fa <GPIO_pin_direction_intialize+0x40>
 3f6:	88 0f       	add	r24, r24
 3f8:	99 1f       	adc	r25, r25
 3fa:	2a 95       	dec	r18
 3fc:	e2 f7       	brpl	.-8      	; 0x3f6 <GPIO_pin_direction_intialize+0x3c>
 3fe:	83 2b       	or	r24, r19
 400:	80 83       	st	Z, r24
 402:	81 e0       	ldi	r24, 0x01	; 1
 404:	08 95       	ret
 406:	e0 81       	ld	r30, Z
 408:	e7 70       	andi	r30, 0x07	; 7
 40a:	f0 e0       	ldi	r31, 0x00	; 0
 40c:	ee 0f       	add	r30, r30
 40e:	ff 1f       	adc	r31, r31
 410:	e9 58       	subi	r30, 0x89	; 137
 412:	ff 4f       	sbci	r31, 0xFF	; 255
 414:	01 90       	ld	r0, Z+
 416:	f0 81       	ld	r31, Z
 418:	e0 2d       	mov	r30, r0
 41a:	30 81       	ld	r19, Z
 41c:	81 e0       	ldi	r24, 0x01	; 1
 41e:	90 e0       	ldi	r25, 0x00	; 0
 420:	02 c0       	rjmp	.+4      	; 0x426 <__EEPROM_REGION_LENGTH__+0x26>
 422:	88 0f       	add	r24, r24
 424:	99 1f       	adc	r25, r25
 426:	2a 95       	dec	r18
 428:	e2 f7       	brpl	.-8      	; 0x422 <__EEPROM_REGION_LENGTH__+0x22>
 42a:	80 95       	com	r24
 42c:	83 23       	and	r24, r19
 42e:	80 83       	st	Z, r24
 430:	81 e0       	ldi	r24, 0x01	; 1
 432:	08 95       	ret
 434:	80 e0       	ldi	r24, 0x00	; 0
 436:	08 95       	ret
 438:	80 e0       	ldi	r24, 0x00	; 0
 43a:	08 95       	ret

0000043c <GPIO_pin_write_logic>:
 43c:	00 97       	sbiw	r24, 0x00	; 0
 43e:	d1 f1       	breq	.+116    	; 0x4b4 <GPIO_pin_write_logic+0x78>
 440:	dc 01       	movw	r26, r24
 442:	2c 91       	ld	r18, X
 444:	26 95       	lsr	r18
 446:	26 95       	lsr	r18
 448:	26 95       	lsr	r18
 44a:	27 70       	andi	r18, 0x07	; 7
 44c:	66 23       	and	r22, r22
 44e:	19 f0       	breq	.+6      	; 0x456 <GPIO_pin_write_logic+0x1a>
 450:	61 30       	cpi	r22, 0x01	; 1
 452:	c9 f0       	breq	.+50     	; 0x486 <GPIO_pin_write_logic+0x4a>
 454:	31 c0       	rjmp	.+98     	; 0x4b8 <GPIO_pin_write_logic+0x7c>
 456:	dc 01       	movw	r26, r24
 458:	ec 91       	ld	r30, X
 45a:	e7 70       	andi	r30, 0x07	; 7
 45c:	f0 e0       	ldi	r31, 0x00	; 0
 45e:	ee 0f       	add	r30, r30
 460:	ff 1f       	adc	r31, r31
 462:	e1 59       	subi	r30, 0x91	; 145
 464:	ff 4f       	sbci	r31, 0xFF	; 255
 466:	01 90       	ld	r0, Z+
 468:	f0 81       	ld	r31, Z
 46a:	e0 2d       	mov	r30, r0
 46c:	30 81       	ld	r19, Z
 46e:	81 e0       	ldi	r24, 0x01	; 1
 470:	90 e0       	ldi	r25, 0x00	; 0
 472:	02 c0       	rjmp	.+4      	; 0x478 <GPIO_pin_write_logic+0x3c>
 474:	88 0f       	add	r24, r24
 476:	99 1f       	adc	r25, r25
 478:	2a 95       	dec	r18
 47a:	e2 f7       	brpl	.-8      	; 0x474 <GPIO_pin_write_logic+0x38>
 47c:	80 95       	com	r24
 47e:	83 23       	and	r24, r19
 480:	80 83       	st	Z, r24
 482:	81 e0       	ldi	r24, 0x01	; 1
 484:	08 95       	ret
 486:	dc 01       	movw	r26, r24
 488:	ec 91       	ld	r30, X
 48a:	e7 70       	andi	r30, 0x07	; 7
 48c:	f0 e0       	ldi	r31, 0x00	; 0
 48e:	ee 0f       	add	r30, r30
 490:	ff 1f       	adc	r31, r31
 492:	e1 59       	subi	r30, 0x91	; 145
 494:	ff 4f       	sbci	r31, 0xFF	; 255
 496:	01 90       	ld	r0, Z+
 498:	f0 81       	ld	r31, Z
 49a:	e0 2d       	mov	r30, r0
 49c:	30 81       	ld	r19, Z
 49e:	81 e0       	ldi	r24, 0x01	; 1
 4a0:	90 e0       	ldi	r25, 0x00	; 0
 4a2:	02 c0       	rjmp	.+4      	; 0x4a8 <GPIO_pin_write_logic+0x6c>
 4a4:	88 0f       	add	r24, r24
 4a6:	99 1f       	adc	r25, r25
 4a8:	2a 95       	dec	r18
 4aa:	e2 f7       	brpl	.-8      	; 0x4a4 <GPIO_pin_write_logic+0x68>
 4ac:	83 2b       	or	r24, r19
 4ae:	80 83       	st	Z, r24
 4b0:	81 e0       	ldi	r24, 0x01	; 1
 4b2:	08 95       	ret
 4b4:	80 e0       	ldi	r24, 0x00	; 0
 4b6:	08 95       	ret
 4b8:	80 e0       	ldi	r24, 0x00	; 0
 4ba:	08 95       	ret

000004bc <GPIO_pin_read_logic>:
 4bc:	00 97       	sbiw	r24, 0x00	; 0
 4be:	f9 f0       	breq	.+62     	; 0x4fe <GPIO_pin_read_logic+0x42>
 4c0:	61 15       	cp	r22, r1
 4c2:	71 05       	cpc	r23, r1
 4c4:	f1 f0       	breq	.+60     	; 0x502 <GPIO_pin_read_logic+0x46>
 4c6:	dc 01       	movw	r26, r24
 4c8:	2c 91       	ld	r18, X
 4ca:	26 95       	lsr	r18
 4cc:	26 95       	lsr	r18
 4ce:	26 95       	lsr	r18
 4d0:	27 70       	andi	r18, 0x07	; 7
 4d2:	ec 91       	ld	r30, X
 4d4:	e7 70       	andi	r30, 0x07	; 7
 4d6:	f0 e0       	ldi	r31, 0x00	; 0
 4d8:	ee 0f       	add	r30, r30
 4da:	ff 1f       	adc	r31, r31
 4dc:	e9 59       	subi	r30, 0x99	; 153
 4de:	ff 4f       	sbci	r31, 0xFF	; 255
 4e0:	01 90       	ld	r0, Z+
 4e2:	f0 81       	ld	r31, Z
 4e4:	e0 2d       	mov	r30, r0
 4e6:	80 81       	ld	r24, Z
 4e8:	90 e0       	ldi	r25, 0x00	; 0
 4ea:	02 c0       	rjmp	.+4      	; 0x4f0 <GPIO_pin_read_logic+0x34>
 4ec:	95 95       	asr	r25
 4ee:	87 95       	ror	r24
 4f0:	2a 95       	dec	r18
 4f2:	e2 f7       	brpl	.-8      	; 0x4ec <GPIO_pin_read_logic+0x30>
 4f4:	81 70       	andi	r24, 0x01	; 1
 4f6:	fb 01       	movw	r30, r22
 4f8:	80 83       	st	Z, r24
 4fa:	81 e0       	ldi	r24, 0x01	; 1
 4fc:	08 95       	ret
 4fe:	80 e0       	ldi	r24, 0x00	; 0
 500:	08 95       	ret
 502:	80 e0       	ldi	r24, 0x00	; 0
 504:	08 95       	ret

00000506 <GPIO_pin_intialize>:
Std_ReturnType GPIO_pin_intialize(const ST_pin_config_t *_pin_config)
{
 506:	cf 93       	push	r28
 508:	df 93       	push	r29
    Std_ReturnType ret = E_NOT_OK;

    if(PTR_NULL == _pin_config)
 50a:	00 97       	sbiw	r24, 0x00	; 0
 50c:	59 f0       	breq	.+22     	; 0x524 <GPIO_pin_intialize+0x1e>
 50e:	ec 01       	movw	r28, r24
    {
        ret = E_NOT_OK;
    }
    else
    {
       ret = GPIO_pin_direction_intialize(_pin_config);
 510:	0e 94 dd 01 	call	0x3ba	; 0x3ba <GPIO_pin_direction_intialize>
       ret = GPIO_pin_write_logic(_pin_config,_pin_config->logic);
 514:	68 81       	ld	r22, Y
 516:	67 fb       	bst	r22, 7
 518:	66 27       	eor	r22, r22
 51a:	60 f9       	bld	r22, 0
 51c:	ce 01       	movw	r24, r28
 51e:	0e 94 1e 02 	call	0x43c	; 0x43c <GPIO_pin_write_logic>
 522:	01 c0       	rjmp	.+2      	; 0x526 <GPIO_pin_intialize+0x20>
{
    Std_ReturnType ret = E_NOT_OK;

    if(PTR_NULL == _pin_config)
    {
        ret = E_NOT_OK;
 524:	80 e0       	ldi	r24, 0x00	; 0
    {
       ret = GPIO_pin_direction_intialize(_pin_config);
       ret = GPIO_pin_write_logic(_pin_config,_pin_config->logic);
    }
    return ret;
}
 526:	df 91       	pop	r29
 528:	cf 91       	pop	r28
 52a:	08 95       	ret

0000052c <_exit>:
 52c:	f8 94       	cli

0000052e <__stop_program>:
 52e:	ff cf       	rjmp	.-2      	; 0x52e <__stop_program>
